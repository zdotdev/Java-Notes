Object-oriented programming is a core of Java Programming, which is used for designing a program using classes and objects. This can also be characterized as data controlling for accessing the code.

# Class 
A class is a group of objects which have common properties. It is a template or blueprint from which objects are created. It is a logical entity. It can't be physical.

Java class contains:
- Fields
- Methods
- Constructor
- Blocks
- Nested class and Interface

Syntax to declare a class:

```java
class <class_name>{  
     field;  
     method;  
}
```
```Java
__access_modifier__ ****class**** <__class_name__>
{  
    data member;  
    method;  
    constructor;
    nested class;
    interface;
}
```

Example:
```Java
// Java Program for class example

class Student {
	// data member (also instance variable)
	int id;
	// data member (also instance variable)
	String name;

	public static void main(String args[])
	{
		// creating an object of
		// Student
		Student s1 = new Student();
		System.out.println(s1.id);
		System.out.println(s1.name);
	}
}
```
## Instance in Java
A variable which is created inside the class but outside the method is known as an instance variable. Instance variable doesn't get memory at compile time. It gets memory at runtime when an object or instance is created. That is why it is known as an instance variable.

## Method in Java 
In Java, a method is like a function which is used to expose the behavior of an object.

Advantage of Method:
- Code Reusability
- Code Optimization

```Java
//Java Program to illustrate how to define a class and fields  
//Defining a Student class.  
class Student{  
//defining fields  
int id;//field or data member or instance variable  
String name;  
//creating main method inside the Student class  
public static void main(String args[]){  
//Creating an object or instance  
	Student s1=new Student();//creating an object of Student  
	//Printing values of the object  
	System.out.println(s1.id);//accessing member through reference variable  
System.out.println(s1.name);  
}  
}
```

# Object and Class Example: main outside the class
We create classes and use it from another class. It is a better approach than previous one. We are having main() method in another class.

```Java
class Student{  
 int id = "12";  
 String name = "Dick";  
}  
class TestStudent1{  
 public static void main(String args[]){  
  Student s1=new Student();  
  System.out.println(s1.id);  
  System.out.println(s1.name);  
 }  
}  
```

We can have multiple classes in different Java files or single Java file. If you define multiple classes in a single Java source file, it is a good idea to save the file name with the class name which has main() method.

## 3 ways to initialize object
1. Reference
2. Method
3. Constructor

## Object and Class example: Initialization through reference
Initializing an object means storing data into the object.

```Java
class Student{  
 int id;  
 String name;  
}  
class TestStudent2{  
 public static void main(String args[]){  
  Student s1=new Student();  
  s1.id=101;  
  s1.name="Sonoo";  
  System.out.println(s1.id+" "+s1.name);//printing members with a white space  
 }  
} 
```

We can also create multiple objects and store information in it through reference variable.

```Java
class Student{  
 int id;  
 String name;  
}  
class TestStudent3{  
 public static void main(String args[]){  
  //Creating objects  
  Student s1=new Student();  
  Student s2=new Student();  
  //Initializing objects  
  s1.id=101;  
  s1.name="Sonoo";  
  s2.id=102;  
  s2.name="Amit";  
  //Printing data  
  System.out.println(s1.id+" "+s1.name);  
  System.out.println(s2.id+" "+s2.name);  
 }  
}  
```

We can also override it like this:

```Java
class Student{  
 int id;  
 String name;  
}  
class TestStudent3{  
 public static void main(String args[]){  
  //Creating objects  
  Student s1=new Student();   
  //Initializing objects  
  s1.id=101;  
  s1.name="Sonoo";  
  s1.id=102;  
  s1.name="Amit";  
  //Printing data  
  System.out.println(s1.id+" "+s1.name);   
 }  
}  
```

## Object and Class Example: Initialization through method
We are creating the two objects of Students class and initializing the value to those objects by invoking the insertrecord method. We are displaying the state (data) of the objects by invoking the displayInformation() method.

```Java
class Student{  
 int rollno;  
 String name;  
 void insertRecord(int r, String n){  
  rollno=r;  
  name=n;  
 }  
 void displayInformation(){System.out.println(rollno+" "+name);}  
}  
class TestStudent4{  
 public static void main(String args[]){  
  Student s1=new Student();  
  Student s2=new Student();  
  s1.insertRecord(111,"Karan");  
  s2.insertRecord(222,"Aryan");  
  s1.displayInformation();  
  s2.displayInformation();  
 }  
}  
```

Or you can use method like this:

```Java
class Return {
    static void test(String a, String b){
        System.out.println(a + " " + b);
    }

    public static void main(String[] args) {
        test("Lamaw", "George");
    }
}
```

Method overloading:
```Java
public class methodOverloading {
    
    static void test(String a, String b){
        System.out.println(a + " " + b);
    }
    static void test(int c, String d){
        System.out.println(c + " " + d);
    }
    static void test(String e, String f, String a){
        System.out.println(e + " " + f + a);
    }
    
    public static void main(String[] args) {
        String a = "A";
        String b = "B";
        int c = 1;
        String d = "D";
        String e = "E";
        String f = "F";
        
        test(a, b);
        test(c, d);
        test(e, f, a);
	}
}
```

## Constructor in Java
In **Java**, a constructor is a block of codes similar to the method. It is called when an instance of the **class** is created. At the time of calling constructor, memory for the object is allocated in the memory.

It is a special type of method which is used to initialize the object.

Every time an object is created using the new() keyword, at least one constructor is called.

It calls a default constructor if there is no constructor available in the class. In such case, Java compiler provides a default constructor by default.

```Java
class Bike1{

Bike1(){
System.out.println("Bike is created");
}

public static void main(String args[]){
Bike1 b=new Bike1();
}
}
```

ex 2 using new():
```Java
class Return {
    public String Return(String a, String b){
        return(a + " " + b);
    }

    public static void main(String[] args) {
        Return Return;
        
        Return = new Return();
        
        String Test = Return.test("Lamaw", "George");
        System.out.println(Test);
    }
}
```

Example of default constructor that displays the default values:

```Java
class Student3{
int id;
String name;

void display(){System.out.println(id+" "+name);}

public static void main(String args[]){
Student3 s1=new Student3();
Student3 s2=new Student3();
s1.display();
s2.display();
}
}
```

default constructor but with multiple class:
```Java
class Student1{
int id = 1;
String name = "Eldifonso";

void display(){System.out.println(id+" "+name);}
}

class Student2{
int id = 2;
String name = "Gregor";

void display(){System.out.println(id+" "+name);}

public static void main(String args[]){
Student1 s1=new Student1();
Student2 s2=new Student2();
s1.display();
s2.display();
}
}
```

Parameterized constructor:
```Java
class Student4{
    int id;
    String name;
    
    Student4(int i,String n){
    id = i;
    name = n;
    }
    void display(){System.out.println(id+" "+name);}
 
    public static void main(String args[]){
    Student4 s1 = new Student4(111,"Karan");
    Student4 s2 = new Student4(222,"Aryan");
    s1.display();
    s2.display();
   }
}
```

Constructor Overloading:
```Java
class Student5{
    int id;
    String name;
    int age;
    Student5(int i,String n){
    id = i;
    name = n;
    }
    Student5(int i,String n,int a){
    id = i;
    name = n;
    age=a;
    }
    void display(){System.out.println(id+" "+name+" "+age);}
 
    public static void main(String args[]){
    Student5 s1 = new Student5(111,"Karan");
    Student5 s2 = new Student5(222,"Aryan",25);
    s1.display();
    s2.display();
   }
}
```

## Difference between constructor and method in java
There are many difference between constructors and methods
![[Pasted image 20231022105017.png]]

## Interface in Java
An Interface in Java programming language is defined as an abstract type used to specify the behavior of a class. An interface in Java is a blueprint of a behavior. A Java interface contains static constants and abstract methods.
![[Pasted image 20231022191627.png]]

Difference between class and interface:
![[Pasted image 20231022191703.png]]

Interface syntax:
```Java
// Java program to demonstrate working of
// interface

import java.io.*;

// A simple interface
interface In1 {

	// public, static and final
	final int a = 10;

	// public and abstract
	void display();
}

// A class that implements the interface.
class TestClass implements In1 {

	// Implementing the capabilities of
	// interface.
	public void display(){ 
	System.out.println("Geek"); 
	}

	// Driver Code
	public static void main(String[] args)
	{
		TestClass t = new TestClass();
		t.display();
		System.out.println(a);
	}
}
```

```Java
// Java program to demonstrate the 
// real-world example of Interfaces

import java.io.*;

interface Vehicle {
	
	// all are the abstract methods.
	void changeGear(int a);
	void speedUp(int a);
	void applyBrakes(int a);
}

class Bicycle implements Vehicle{
	
	int speed;
	int gear;
	
	// to change gear
	@Override
	public void changeGear(int newGear){
		
		gear = newGear;
	}
	
	// to increase speed
	@Override
	public void speedUp(int increment){
		
		speed = speed + increment;
	}
	
	// to decrease speed
	@Override
	public void applyBrakes(int decrement){
		
		speed = speed - decrement;
	}
	
	public void printStates() {
		System.out.println("speed: " + speed
			+ " gear: " + gear);
	}
}

class Bike implements Vehicle {
	
	int speed;
	int gear;
	
	// to change gear
	@Override
	public void changeGear(int newGear){
		
		gear = newGear;
	}
	
	// to increase speed
	@Override
	public void speedUp(int increment){
		
		speed = speed + increment;
	}
	
	// to decrease speed
	@Override
	public void applyBrakes(int decrement){
		
		speed = speed - decrement;
	}
	
	public void printStates() {
		System.out.println("speed: " + speed
			+ " gear: " + gear);
	}
	
}
class GFG {
	
	public static void main (String[] args) {
	
		// creating an instance of Bicycle
		// doing some operations
		Bicycle bicycle = new Bicycle();
		bicycle.changeGear(2);
		bicycle.speedUp(3);
		bicycle.applyBrakes(1);
		
		System.out.println("Bicycle present state :");
		bicycle.printStates();
		
		// creating instance of the bike.
		Bike bike = new Bike();
		bike.changeGear(1);
		bike.speedUp(4);
		bike.applyBrakes(3);
		
		System.out.println("Bike present state :");
		bike.printStates();
	}
}

```

**Advantage of Interface in Java**
1. Without bothering about the implementation part, we can achieve the security of the implementation.
2. In Java, multiple inheritances are not allowed, however, you can use an interface to make use of it as you can implement more than one interface.

**Extending Interfaces**
One interface can inherit another by the use of keyword extends. When a class implements an interface that inherits another interface, it must provide an implementation for all methods required by the interface inheritance chain.

```Java
//Program 1
interface A {
	void method1();
	void method2();
}
// B now includes method1 and method2
interface B extends A {
	void method3();
}
// the class must implement all method of A and B.
class gfg implements B {
	public void method1()
	{
		System.out.println("Method 1");
	}
	public void method2()
	{
		System.out.println("Method 2");
	}
	public void method3()
	{
		System.out.println("Method 3");
	}
}
```

```Java
//Program 2
interface Student 
{
	public void data();
	
}
class avi implements Student
{
	public void data ()
	{
		String name="avinash";
		int rollno=68;
		System.out.println(name);
		System.out.println(rollno);
	}
}
public class inter_face 
{
	public static void main (String args [])
	{
		avi h= new avi();
		h.data();
	}
}
```

## Market Interface in Java
It is an empty interface (no field or methods). Examples of market interface re Serializable, Cloneable, and Remote interface. All these interface are empty interface.
```Java
public interface Serialization{
	//Nothing here
}
```

Examples of Market Interface which are used in real-time application:

1. Cloneable interface - Cloneable interface is present in java.lang package. There is a method `clone()` in Object class. A class that implements the Cloneable interface indicates that it is legal for `clone()` method to make a field-for-field copy of instances of that class. Invoking Object’s clone method on an instance of the class that does not implement the Cloneable interface results in an exception `CloneNotSupportedException` being thrown. By convention, classes that implement this interface should override `Object.clone()` method.
```Java
//Java program to illustrate Cloneable interface
import java.lang.*;

//by implementing Cloneable interface we make sure that instance of class A can be cloned.
class A implements Cloneable{
    int i;
    String s;
	
	//A class Constructor
    public A(int i, String s){
        this.i = i;
        this.s = s;
    }
	
	//Overriding clone() method by simply calling Object class clone() method.
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
        
    }
}
public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        A a = new A(69, "jabol");
        
        //Cloning 'a' and holding new cloned object reference in b
        //down-casting as clone() return type is Object 
        A b = (A)a.clone();
        
        System.out.println(b.i);
        System.out.println(b.s);
    }
}
```

2. **Serialization interface** - is present in java.io package. It is used to make an object eligible for saving its state into a file. This is called Serialization. Classes that do not implement this interface will not have any of their state serialized or deserialized. All subtypes of a serializable class are themselves serializable.
```java
// Java program to illustrate Serializable interface 
import java.io.*; 

// By implementing Serializable interface 
// we make sure that state of instances of class A 
// can be saved in a file. 
class A implements Serializable 
{ 
	int i; 
	String s; 

	// A class constructor 
	public A(int i,String s) 
	{ 
		this.i = i; 
		this.s = s; 
	} 
} 

public class Test 
{ 
	public static void main(String[] args) 
	throws IOException, ClassNotFoundException 
	{ 
		A a = new A(20,"GeeksForGeeks"); 

		// Serializing 'a' 
		FileOutputStream fos = new FileOutputStream("xyz.txt"); 
		ObjectOutputStream oos = new ObjectOutputStream(fos); 
		oos.writeObject(a); 

		// De-serializing 'a' 
		FileInputStream fis = new FileInputStream("xyz.txt"); 
		ObjectInputStream ois = new ObjectInputStream(fis); 
		A b = (A)ois.readObject();//down-casting object 

		System.out.println(b.i+" "+b.s); 

		// closing streams 
		oos.close(); 
		ois.close(); 
	} 
} 
```

3. **Remote interface** - is present in java.rmi package. A remote object is an object which is stored at one machine and accessed from another machine. So, to make an object a remote object, we need to flag it with Remote interface. Here, Remote interface serves to identify interfaces whose methods may be invoked from a non-local virtual machine. Any object that is a remote object must directly or indirectly implement this interface. RMI (Remote Method Invocation) provides some convenience classes that remote object implementations can extend which facilitate remote object creation.
## Object 
An entity that has state and behavior is known as an object e.g., chair, bike, marker, pen, table, car, etc. It can be physical or logical (tangible and intangible).

Real world example: 
Bag is the class, it contains school supplies(object) like pencil, notebook, and eraser.

A typical Java program creates many objects, which as you know, interact by invoking methods. An object consists of :

1. **State**: It is represented by attributes of an object. It also reflects the properties of an object.
2. **Behavior**: It is represented by the methods of an object. It also reflects the response of an object with other objects.
3. **Identity**: It gives a unique name to an object and enables one object to interact with other objects.

Example of an object: dog
![[Pasted image 20231024115242.png]]

Objects correspond to things found in the real world. For example, a graphics program may have objects such as “circle”, “square”, and “menu”. An online shopping system might have objects such as “shopping cart”, “customer”, and “product”.

**Note:** When we create an object which is a non primitive data type, it’s always allocated on the heap memory.

## Declaring Objects (Also called instantiating a class)

When an object of a class is created, the class is said to be **instantiated**. All the instances share the attributes and the behavior of the class. But the values of those attributes, i.e. the state are unique for each object. A single class may have any number of instances.
![[Pasted image 20231024115841.png]]

As we declare variable like (type name;). This notifies the compiler that we will use the name to refer to data whose type is type. With a primitive variable, this declaration also reserves the proper amount of memory for the variables. So for reference variables, the type must be strictly aa concrete class name. in general, we cant create objects of an abstract class or interface.

**Initializing a Java object**
The new operator instantiates a class by allocating memory for a new object and returning a reference to that memory. The new operator also invokes the class constructor.

Example:
```Java
// Class Declaration

public class Dog {
	// Instance Variables
	String name;
	String breed;
	int age;
	String color;

	// Constructor Declaration of Class
	public Dog(String name, String breed, int age,
			String color)
	{
		this.name = name;
		this.breed = breed;
		this.age = age;
		this.color = color;
	}

	// method 1
	public String getName() { return name; }

	// method 2
	public String getBreed() { return breed; }

	// method 3
	public int getAge() { return age; }

	// method 4
	public String getColor() { return color; }

	@Override public String toString()
	{
		return ("Hi my name is " + this.getName()
				+ ".\nMy breed,age and color are "
				+ this.getBreed() + "," + this.getAge()
				+ "," + this.getColor());
	}

	public static void main(String[] args)
	{
		//tuffy is the object
		Dog tuffy = new Dog("tuffy", "papillon", 5, "white");
		System.out.println(tuffy.toString());
	}
}
```

**Initialize by using method/function**
```Java
public class GFG {
	// sw=software
	static String sw_name;
	static float sw_price;
	
	//This is a constructor because of the arguments inside it(it doesn't matter if the name of the constructor and the class is different)
	static void set(String n, float p)
	{   
	    //setting the variable name
		sw_name = n;
		sw_price = p;
	}

	static void get()
	{
	    //this method gets the value of set
		System.out.println("Software name is: " + sw_name);
		System.out.println("Software price is: " + sw_price);
	}

	public static void main(String args[])
	{
	    //declaring the variable value
		GFG.set("Visual studio", 0.0f);
		//echo the get method with the set method variable
		GFG.get();
	}
}
```

The class contains single constructor. We can recognize a constructor because its declaration uses the same name as the class and it has no return type. The Java compiler differentiates the constructors based on the number and the type of the arguments. The constructor in the *Dog* class takes four arguments. The following statements provides "Tuffy", "papillon", 5, and "white" as values for those arguments:

```Java
Dog tuffy = new Dog("Tuffy", "papillon", 5, "white");
```

The result of executing this statement can be illustrated as:
![[Pasted image 20231024131801.png]]

**Note:** All classes have at least **one** constructor. If a class does not explicitly declare any, the Java compiler automatically provides a no-argument constructor, also called the default constructor. This default constructor calls the class parent’s no-argument constructor (as it contains only one statement i.e super();), or the __Object__ class constructor if the class has no other parent (as the Object class is the parent of all classes either directly or indirectly).

## Ways to Create an Object of a Class
There are four ways to create objects in Java. Strictly speaking, there is only one way(by using a __new__ keyword), and the rest internally use a __new__ keyword.

1. Using `new` keyword
it is the most common and general way to create an object in Java.
```Java
// creating object of class Test
public class Main
{
    int i = 10;
	public static void main(String[] args){
		Main newMain = new Main();
		System.out.println(newMain.i);
	}
}
```

2. Using `Class.forName(String className)` method.
There is a pre-defined class in java.lang package with name `Class`. The `forName(String className)` method returns the Class Object associated with the class with the given string name. We have to give a fully qualified name for a class. On calling the `newInstance()` method on this Class Object returns a new instance of the class with the given string name.(Di ko pa alam gawin yang last sentence hahaha)
```Java
//method 1
public class Main{
	int x = 10;
	
	//Add throws InstantiationException and IllegalAccessException to prevent errorsd
	public static void main(String[] args) throws InstantiationException, IllegalAccessException {
	
	//Method 1 in using newInstance() method
	Main newMain = Main.class.newInstance();
	System.out.println(newMain.x);
	}
}
```

```java
//di pa to ok
public class Main{

int x = 10;

public static void main(String[] args) throws InstantiationEsception, IllegalAccessException, ClassNotFoundException {

Main newMain = (Main) Class.forName("Main").newInstance();

System.out.println(newMain.x);
}

}
```

```Java
public class CreateObjectExample4 {   
void show() {    
System.out.println("A new object created.");    
}
public static void main(String[] args) throws InstantiationException, ClassNotFoundException, IllegalAccessException {   

//creating an instance of Class class  
Class cls = Class.forName("CreateObjectExample4"); 

//creates an instance of the class using the newInstance() method  
CreateObjectExample4 obj = (CreateObjectExample4) cls.newInstance();  

//invoking the show() method  
obj.show();       
	}   
} 
```

3. Using `Clone()` method.
`clone()` method is present in the Object class. It creates and returns a copy of the object.
```Java
public class Main{
	int x = 10;
	public static void main(String[] args){
	//Creating object of class Main
	Main numOne = new Main();
	Main numTwo = (Main)numOne.clone();
	}
}
```

4. Deserialization is a technique of reading an object from the saved state in a file. In Java, **Serialization** is the process of converting an object into a sequence of byte-stream. The reverse process (byte-stream to object) of serialization is called deserialization. The JVM creates a new object when we serialize or deserialize an object. It does not use constructor to create an object. While using deserialization, the **Serializable** interface (*marker interface*) must be implemented in the class.

**.ser** - SER files mostly belong to Java Development Key. SER files are used to store serialized objects of Java Program.

![[Pasted image 20231024222610.png]]
**Serialization** - The `writeObject()` method of the **ObjectOutputStream** class is used to serialize an object. it sends the object to the output stream.

```Java
public final void writeObject(object x) throws IOException
```

```Java
import java.io.*;
 
/**
 * This program is used to show the serialization process.
 * @author w3spoint
 */
class Student implements Serializable{
	//Serial Version UID.
	private static final long serialVersionUID = 1L;
	String name;
	String className;
	String rollNo;
 
	//Constructor.
	Student(String name, String className, String rollNo){
		this.name = name;
		this.className = className;
		this.rollNo = rollNo;
	}
}
 
class Test{
	//Write serialized object into objectoutputstream.
	public void objectSerialization(Student stu){
	   try
	      {
	         //Creating FileOutputStream object.
	         FileOutputStream fos = 
	          new FileOutputStream("F:\\New folder\\student.ser");
 
	         //Creating ObjectOutputStream object.
	         ObjectOutputStream oos = new ObjectOutputStream(fos);
 
	         //write object.
	         oos.writeObject(stu);
 
	         //close streams.
	         oos.close();
	         fos.close();
 
	         System.out.println("Serialized data is saved in " +
	         		"F:\\New folder\\student.ser");
	      }catch(IOException e)
	      {
	          System.out.println(e);
	      }
	}
}
 
public class SerializationExample {
	public static void main(String args[]){
		//Creating Student object.
		Student stu = 
                 new Student("Parmander", "MCA", "MCA/07/27");		
		//Creating Test object.
		Test obj = new Test();		
		//Method call.
		obj.objectSerialization(stu);		
	}
}
```

**Deserialization** - The method `readObject()` of **ObjectInputStream** class is used to deserialize an object. It references objects out of a stream.
```Java
public final Object readObject() throws IOException,ClassNotFoundException
```

```Java
import java.io.*;
 
/**
 * This program is used to show the deserialization process.
 * @author w3spoint
 */
class Student implements Serializable{
	//Serial Version UID.
	private static final long serialVersionUID = 1L;
	String name;
	String className;
	String rollNo;
 
	//Constructor.
	Student(String name, String className, String rollNo){
		this.name = name;
		this.className = className;
		this.rollNo = rollNo;
	}
}
 
class Test{
	//Deserialize a serialize object.
	public void objectDeSerialization(){
	  try
	      {
		Student stu = null;
		//Creating FileOutputStream object.
		FileInputStream fis = 
	         new FileInputStream("F:\\New folder\\student.ser");
 
	         //Creating ObjectOutputStream object.
	         ObjectInputStream ois = new ObjectInputStream(fis);
 
	         //write object.
	         stu = (Student) ois.readObject();
 
	         //close streams.
	         ois.close();
	         fis.close();
 
	         System.out.println("Name = " + stu.name);
	         System.out.println("Class Name = " + stu.className);
	         System.out.println("RollNo = " + stu.rollNo);
	      }catch(Exception e)
	      {
	          System.out.println(e);
	      }
	}
}
 
public class DeSerializationExample {
	public static void main(String args[]){	
		//Creating Test object.
		Test obj = new Test();		
		//Method call.
		obj.objectDeSerialization();		
	}
}
```

## Creating multiple objects by one type only (A good practice)

In real-time, we need different objects of a class in different methods. Creating a number of references for storing them is not a good practice and therefor we declare a static reference variable and use it whenever required. In this case, the wastage of memory is less. The objects that are not referenced anymore will be destroyed by the Garbage Collector of Java.
```Java
Test test = new Test();
test = new Test();
```

In the inheritance system, we use a parent class reference variable to store a sub-class object. In this case, we can switch into different subclass using the same referenced variable.

Example:
```Java
import java.io.*;

class Animal {
    public void makeSound() {
        System.out.println("Hello, World!");
    }
}

class Dog extends Animal {
    // You can override the makeSound method for Dog
    @Override
    public void makeSound() {
        System.out.println("Dog says: Woof!");
    }
}

class Cat extends Animal {
    // You can override the makeSound method for Cat
    @Override
    public void makeSound() {
        System.out.println("Cat says: Meow!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal objOne = new Dog(); // Using Dog object
        Animal objTwo = new Cat(); // Using Cat object
        Animal objThree = new Animal();
        
        objThree.makeSound();
        objOne.makeSound(); // Calls the makeSound method of Dog
        objTwo.makeSound(); // Calls the makeSound method of Cat
    }
}
```

**@Override** - A feature that allows a subclass or child class to provide a specific implementation of a method that is already provided by one of its suer-classes.

## Anonymous Object in Java
Anonymous objects are objects that are instantiated but are not stored in a reference variable.

- They are used for immediate methods calls.
- They will be destroyed after method after method calling. 
- They are widely used in different libraries. For example, in AWT libraries, they are use to perform some action on capturing an event(eg key press).
- In the example below, when a key button (referred to by the btn) is pressed, we are simply creating an anonymous object of EventHandler class for just calling the handle method.
```Java
btn.setOnAction(new EventHandler){
public void handle(ActionEvent event){
System.out.println("Hello World");
}
}
```
**awt library** - Abstract Windows Toolkit is an API(Application Programming Interface) used for developing GUI(Graphical User Interface) or Window-Base application in Java. Java AWT is part of the Java Foundation Classes (JFC) that provides a way to build platform-independent graphical application.

# Inheritance in Java
## Why Do We Need Java Inheritance?

- **Code Reusability:** The code written in the Superclass is common to all subclasses. Child classes can directly use the parent class code.
- **Method Overriding:** Method Overriding is achievable only through Inheritance. It is one of the ways by which Java achieves Run Time Polymorphism.
- **Abstraction:** The concept of abstract where we do not have to provide all details is achieved through inheritance. Abstraction only shows the functionality to the user.

### Important Terminologies Used in Java Inheritance
- **Class:** Class is a set of objects which shares common characteristics/ behavior and common properties/ attributes. Class is not a real-world entity. It is just a template or blueprint or prototype from which objects are created.
- **Super Class/Parent Class:** The class whose features are inherited is known as a superclass(or a base class or a parent class).
- **Sub Class/Child Class:** The class that inherits the other class is known as a subclass(or a derived class, extended class, or child class). The subclass can add its own fields and methods in addition to the superclass fields and methods.
- **Reusability:** Inheritance supports the concept of “reusability”, i.e. when we want to create a new class and there is already a class that includes some of the code that we want, we can derive our new class from the existing class. By doing this, we are reusing the fields and methods of the existing class.

## How to Use Inheritance in Java?
The **extends keyword** is used for inheritance in Java. Using the extends keyword indicates you are derived from an existing class. In other words, “extends” refers to increased functionality.

```java
// Java program to illustrate the
// concept of inheritance
 
// base class
class Bicycle {
    // the Bicycle class has two fields
    public int gear;
    public int speed;
 
    // the Bicycle class has one constructor
    public Bicycle(int gear, int speed)
    {
        this.gear = gear;
        this.speed = speed;
    }
 
    // the Bicycle class has three methods
    public void applyBrake(int decrement)
    {
        speed -= decrement;
    }
 
    public void speedUp(int increment)
    {
        speed += increment;
    }
 
    // toString() method to print info of Bicycle
    public String toString()
    {
        return ("No of gears are " + gear + "\n"
                + "speed of bicycle is " + speed);
    }
}
 
// derived class
class MountainBike extends Bicycle {
 
    // the MountainBike subclass adds one more field
    public int seatHeight;
 
    // the MountainBike subclass has one constructor
    public MountainBike(int gear, int speed,
                        int startHeight)
    {
        // invoking base-class(Bicycle) constructor
        super(gear, speed);
        seatHeight = startHeight;
    }
 
    // the MountainBike subclass adds one more method
    public void setHeight(int newValue)
    {
        seatHeight = newValue;
    }
 
    // overriding toString() method
    // of Bicycle to print more info
    @Override public String toString()
    {
        return (super.toString() + "\nseat height is "
                + seatHeight);
    }
}
 
// driver class
public class Test {
    public static void main(String args[])
    {
 
        MountainBike mb = new MountainBike(3, 100, 25);
        System.out.println(mb.toString());
    }
}
```

Sir Lorimer example:
```java
class person{
    public void personalInfo(){
        System.out.println("Hi, I am the Manager!!!");
    }
}
class employee extends person{
    @Override public void personalInfo(){
        System.out.println("Hi, I am the Employee!!!");
        System.out.println("My ID: 1234");
    }
}
class teacher extends person{
    @Override public void personalInfo(){
        System.out.println("Hi, I am the Teacher!!!");
        System.out.println("My ID: 0987");
    }
}
class student extends person{
    @Override public void personalInfo(){
        System.out.println("Hi, I am the Student!!!");
        System.out.println("My ID: 246372!!!");
    }
}
public class Overriding {

    public static void main(String[] args) {
        person p = new person();
        p.personalInfo();
        System.out.println("===========================");
        employee e = new employee();
        e.personalInfo();
        System.out.println("===========================");
        teacher t = new teacher();
        t.personalInfo();
        System.out.println("===========================");
        student s = new student();
        s.personalInfo();
    }
}
```

```java
// Java Program to illustrate Inheritance (concise)
 
import java.io.*;
 
// Base or Super Class
class Employee {
    int salary = 60000;
}
 
// Inherited or Sub Class
class Engineer extends Employee {
    int benefits = 10000;
}
 
// Driver Class
class Overriding {
    public static void main(String args[])
    {
        Engineer E1 = new Engineer();
        System.out.println("Salary : " + E1.salary + "\nBenefits : " + E1.benefits);
    }
}
```

![[Pasted image 20231119180015.png]]

## Java Inheritance Types
Below are the different types of inheritance which are supported by Java.

1. Single Inheritance
2. Multilevel Inheritance
3. Hierarchical Inheritance
4. Multiple Inheritance
5. Hybrid Inheritance

### 1. Single Inheritance
In single inheritance, subclasses inherit the features of one superclass. In the image below, class A serves as a base class for the derived class B.
![[Pasted image 20231119180424.png]]

```java
// Java program to illustrate the
// concept of single inheritance
import java.io.*;
import java.lang.*;
import java.util.*;

// Parent class
class One {
	public void print_geek()
	{
		System.out.println("Geeks");
	}
}

class Two extends One {
	public void print_for() { System.out.println("for"); }
}

// Driver class
public class Main {
	// Main function
	public static void main(String[] args)
	{
		Two g = new Two();
		g.print_geek();
		g.print_for();
		g.print_geek();
	}
}
```

### 2. Multilevel Inheritance
In Multilevel Inheritance, a derived class will be inheriting a base class, and as well as the derived class also acts as the base class for other classes. In the below image, class A serves as a base class for the derived class B, which in turn serves as a base class for the derived class C. In Java, a class cannot directly access the **grandparent’s members**.
![[Pasted image 20231119180528.png]]

```java
// Java program to illustrate the
// concept of Multilevel inheritance
import java.io.*;
import java.lang.*;
import java.util.*;

class One {
	public void print_geek()
	{
		System.out.println("Geeks");
	}
}

class Two extends One {
	public void print_for() { System.out.println("for"); }
}

class Three extends Two {
	public void print_geek()
	{
		System.out.println("Geeks");
	}
}

// Drived class
public class Main {
	public static void main(String[] args)
	{
		Three g = new Three();
		g.print_geek();
		g.print_for();
		g.print_geek();
	}
}
```

### 3. Hierarchical Inheritance
In Hierarchical Inheritance, one class serves as a superclass (base class) for more than one subclass. In the below image, class A serves as a base class for the derived classes B, C, and D.
![[Pasted image 20231119180745.png]]
```java
// Java program to illustrate the
// concept of Hierarchical inheritance

class A {
	public void print_A() { System.out.println("Class A"); }
}

class B extends A {
	public void print_B() { System.out.println("Class B"); }
}

class C extends A {
	public void print_C() { System.out.println("Class C"); }
}

class D extends A {
	public void print_D() { System.out.println("Class D"); }
}

// Driver Class
public class Test {
	public static void main(String[] args)
	{
		B obj_B = new B();
		obj_B.print_A();
		obj_B.print_B();

		C obj_C = new C();
		obj_C.print_A();
		obj_C.print_C();

		D obj_D = new D();
		obj_D.print_A();
		obj_D.print_D();
	}
}
```

### 4. Multiple Inheritance (****Through Interfaces)****

In [Multiple inheritances](https://www.geeksforgeeks.org/java-and-multiple-inheritance/), one class can have more than one superclass and inherit features from all parent classes. Please note that Java does ****not**** support [multiple inheritances](https://www.geeksforgeeks.org/java-and-multiple-inheritance/) with classes. In Java, we can achieve multiple inheritances only through [Interfaces](https://www.geeksforgeeks.org/interfaces-in-java/). In the image below, Class C is derived from interfaces A and B.
![[Pasted image 20231119181556.png]]

```java
// Java program to illustrate the
// concept of Multiple inheritance
import java.io.*;
import java.lang.*;
import java.util.*;

interface One {
	public void print_geek();
}

interface Two {
	public void print_for();
}

interface Three extends One, Two {
	public void print_geek();
}
class Child implements Three {
	@Override public void print_geek()
	{
		System.out.println("Geeks");
	}

	public void print_for() { System.out.println("for"); }
}

// Drived class
public class Main {
	public static void main(String[] args)
	{
		Child c = new Child();
		c.print_geek();
		c.print_for();
		c.print_geek();
	}
}
```

### 5. Hybrid Inheritance
It is a mix of two or more of the above types of inheritance. Since Java doesn’t support multiple inheritances with classes, hybrid inheritance involving multiple inheritance is also not possible with classes. In Java, we can achieve hybrid inheritance only through [Interfaces](https://www.geeksforgeeks.org/interfaces-in-java/) if we want to involve multiple inheritance to implement Hybrid inheritance.  
However, it is important to note that Hybrid inheritance does not necessarily require the use of Multiple Inheritance exclusively. It can be achieved through a combination of Multilevel Inheritance and Hierarchical Inheritance with classes, Hierarchical and Single Inheritance with classes. Therefore, it is indeed possible to implement Hybrid inheritance using classes alone, without relying on multiple inheritance type.

## Java IS-A type of Relationship
IS-A is a way of saying: This object is a type of that object. Let us see how the extends keyword is used to achieve inheritance.

```java
public class SolarSystem {
}
public class Earth extends SolarSystem {
}
public class Mars extends SolarSystem {
}
public class Moon extends Earth {
}
```

Now, based on the above example, in Object-Oriented terms, the following are true:-
- SolarSystem is the superclass of Earth class.
- SolarSystem is the superclass of Mars class.
- Earth and Mars are subclasses of SolarSystem class.
- Moon is the subclass of both Earth and SolarSystem classes.

```java
class SolarSystem {
}
class Earth extends SolarSystem {
}
class Mars extends SolarSystem {
}
public class Moon extends Earth {
	public static void main(String args[])
	{
		SolarSystem s = new SolarSystem();
		Earth e = new Earth();
		Mars m = new Mars();

		System.out.println(s instanceof SolarSystem);
		System.out.println(e instanceof Earth);
		System.out.println(m instanceof SolarSystem);
	}
}
```

## What Can Be Done in a Subclass?
In sub-classes we can inherit members as is, replace them, hide them, or supplement them with new members: 

- The inherited fields can be used directly, just like any other fields.
- We can declare new fields in the subclass that are not in the superclass.
- The inherited methods can be used directly as they are.
- We can write a new __instance__ method in the subclass that has the same signature as the one in the superclass, thus **overriding** it (as in the example above, __toString()__ method is overridden).
- We can write a new __static__ method in the subclass that has the same signature as the one in the superclass, thus **hiding** it.
- We can declare new methods in the subclass that are not in the superclass.
- We can write a subclass constructor that invokes the constructor of the superclass, either implicitly or by using the keyword **super**.
### Advantages Of Inheritance in Java:
1. Code Reusability: Inheritance allows for code reuse and reduces the amount of code that needs to be written. The subclass can reuse the properties and methods of the superclass, reducing duplication of code.
2. Abstraction: Inheritance allows for the creation of abstract classes that define a common interface for a group of related classes. This promotes abstraction and encapsulation, making the code easier to maintain and extend.
3. Class Hierarchy: Inheritance allows for the creation of a class hierarchy, which can be used to model real-world objects and their relationships.
4. Polymorphism: Inheritance allows for polymorphism, which is the ability of an object to take on multiple forms. Subclasses can override the methods of the superclass, which allows them to change their behavior in different ways.
### Disadvantages of Inheritance in Java:
1. Complexity: Inheritance can make the code more complex and harder to understand. This is especially true if the inheritance hierarchy is deep or if multiple inheritances is used.
2. Tight Coupling: Inheritance creates a tight coupling between the superclass and subclass, making it difficult to make changes to the superclass without affecting the subclass.

## Conclusion

Let us check some important points from the article are mentioned below:

- Default superclass: Except **Object** class, which has no superclass, every class has one and only one direct superclass (single inheritance). In the absence of any other explicit superclass, every class is implicitly a subclass of the Object class.
- Superclass can only be one: A superclass can have any number of subclasses. But a subclass can have only **one** superclass. This is because Java does not support multiple inheritances with classes. Although with interfaces, multiple inheritances are supported by Java.
- Inheriting Constructors: A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.
- Private member inheritance: A subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods(like getters and setters) for accessing its private fields, these can also be used by the subclass.

## FAQs in Inheritance
1. What is Inheritance Java?
Inheritance is a concept of OOPs where one class inherits from another class that can reuse the methods and fields of the parent class.

2. What are the 4 types of inheritance in Java?
There are Single, Multiple, Multilevel, and Hybrid.

3. What is the use of extend keyword?
Extend keyword is used for inheriting one class into another.

4. What is an example of inheritance in Java?
A real-world example of Inheritance in Java is mentioned below:

Consider a group of vehicles. You need to create classes for Bus, Car, and Truck. The methods fuelAmount(), capacity(), applyBrakes() will be the same for all three classes.

# Polymorphism in Java
**Polymorphism in Java** is a concept by which we can perform a _single action in different ways_.

There are two types of polymorphism in Java: 
compile-time polymorphism (overloading) and runtime polymorphism(overriding).

**Overloading**
```Java
public class Main
{
    public static int A(int a, int b){
        return(a + b);
    }
    public static float A(float c, float d){
        return(c + d);
    }
    
	public static void main(String[] args) {
		Main m = new Main();
		
		System.out.println("1st A: " + m.A(60, 9));
		System.out.println("2nd A: " + m.A(61.00f, 8.10f));
	}
}
```

**Overriding**
```Java
class Animal{
    public void display(){
        System.out.println("Animal Sound");
    }
}

class dog extends Animal{
    @Override
    public void display(){
        System.out.println("Bark");
    }
}

class cat extends Animal{
    @Override
    public void display(){
        System.out.println("Meow");
    }
}

public class Main
{
	public static void main(String[] args) {
		dog d = new dog();
		cat c = new cat();
		
		d.display();
		c.display();
	}
}
```
## Runtime Polymorphism in Java
**Runtime polymorphism** or **Dynamic Method Dispatch** is a process in which a call to an overridden method is resolved at runtime rather than compile-time.

In this process, an overridden method is called through the reference variable of a superclass. The determination of the method to be called is based on the object being referred to by the reference variable.

Let's first understand the upcasting before Runtime Polymorphism.
### Upcasting
If the reference variable of Parent class refers to the object of Child class, it is known as upcasting. For example:
![[Pasted image 20231119215235.png]]
```java
class A{}  
class B extends A{}

A a=new B();//upcasting
```

For upcasting, we can use the reference variable of class type or an interface type. For Example:
```java
interface I{}  
class A{}  
class B extends A implements I{}
```

Here, the relationship of B class would be:
```java
B IS-A A
B IS-A I
B IS-A Object
```
Since Object is the root class of all classes in Java, so we can write B IS-A Object.

### Example of Java Runtime Polymorphism
In this example, we are creating two classes Bike and Splendor. Splendor class extends Bike class and overrides its run() method. We are calling the run method by the reference variable of Parent class. Since it refers to the subclass object and subclass method overrides the Parent class method, the subclass method is invoked at runtime.

Since method invocation is determined by the JVM not compiler, it is known as runtime polymorphism.
```java
class Bike{  
  void run(){System.out.println("running");}  
}  
class Splendor extends Bike{  
  void run(){System.out.println("running safely with 60km");}  

  public static void main(String args[]){  
    Bike b = new Splendor();//upcasting  
    b.run();  
  }  
}
```

# Abstraction
In simple terms, abstraction “displays” only the relevant attributes of objects and “hides” the unnecessary details.

For example, when we are driving a car, we are only concerned about driving the car like start/stop the car, accelerate/ break, etc. We are not concerned about how the actual start/stop mechanism or accelerate/brake process works internally. We are just not interested in those details.

## Two types of Abstraction in OOP
The difference between Abstract and Interface are: You can extend as many interface as you want in java, but you can only implement one class. You have to declare every variables and all interfaces will have the same value of variable. In interface, you don't have to declare variables, it doesn't matter. Meaning, all object like cat object, dog object, or horse object can have different value in terms of variables.


The `abstract` keyword is a non-access modifier, used for classes and methods:

- **Abstract class:** is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class).
  
- **Abstract method:** can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from).

```Java
abstract class Animal{
	public abstract void animalSound();// Abstract methods must be empty, you can override it in the child class
	
	// Non abstract class doesn't have to be inherited in the child class
	public void sleep(){
		System.out.println("Zzz");
	}
}

// Child Class
class dog extends Animal{ 
    public void animalSound(){
        System.out.println("lamaw");
    }
}

public class Main
{
	public static void main(String[] args) {
		dog d = new dog();
		d.animalSound();
	}
}
```
### Data Abstraction 
In data abstraction, we mostly create complex data types and hide their implementation. We only expose the operations to manipulate these data types without going into the details of their implementation.

One advantage of this approach is that we can change the implementation anytime without changing the behavior that is exposed to the user.
### Control Abstraction
Control abstraction collects all the control statements that are a part of the application and exposes them as a unit. This feature is used when we have to perform a working feature using this control unit.

Control abstraction forms the main unit of structured programming and using control abstraction we can define simple functions in complex frameworks.
![[Pasted image 20231205105655.png]]

## Abstract and Interface
![[Pasted image 20231206191826.png]]

### Frequently Asked Questions

**Q #1) Is Abstraction and Data hiding the same?**

**Answer:** No, Abstraction and Data hiding is not the same. But both are important features of object-oriented programming. While abstraction is a process of hiding the background details, data hiding is a technique of insulating the data from direct access.

**Q #2) What are the Advantages of Abstraction?**

**Answer:** **Few advantages of Abstraction are given below:**

- By hiding the background details and exposing only the abstract view to the user, abstraction makes code simpler and more readable.
- As abstraction shields unnecessary details, it makes code smaller.
- Code maintenance can become complex and difficult without abstraction.

**Q #3) Why is Abstraction so important?**

**Answer:** Abstraction allows us to hide background details that are important and can lead to chaos if leaked to the world. By hiding the background details and exposing only the required interface to the user, abstraction makes applications simpler.

**Q #4) Explain Abstraction with a real-time example.**

**Answer:** There are many real-time examples of abstraction including geometric shapes, vehicles, etc. Yet another example is the ATM (Automated Teller Machine). The ATM supports operations like cash withdrawal, balance checking, money transfer, etc. But we are not aware of how these operations work internally.

We are only given a monitor with a user interface to select and perform the required operations.

**Q #5) Can we achieve Abstraction without Encapsulation?**

**Answer:** Abstraction shields the implementation details and encapsulation hides the object details. The object is the abstract form of the real world and its details are hidden using encapsulation. Thus encapsulation is required for abstraction.

## Conclusion

In this tutorial, we have discussed abstraction in Java in detail. Abstraction is a technique of hiding unnecessary details from the user. The user is only given access to the details that are relevant. Vehicle operations or ATM operations are classic examples of abstractions in the real world.

When we use ATMs, we are only interested in performing the operations like cash withdrawal, etc without having to know the details about how exactly that operation is performed internally.

Java provides abstraction through abstract classes and interfaces. While interfaces provide 100 % abstraction, abstract classes provide partial abstraction. The choice between interfaces and abstract classes should be made depending on the application to be developed and also what information is to be exposed to the user.

We also discussed the abstract methods in this tutorial along with the differences between abstract classes and interfaces.

# Encapsulation
## Java Encapsulation

Encapsulation is one of the key features of object-oriented programming. Encapsulation refers to the bundling of fields and methods inside a single class.

It prevents outer classes from accessing and changing fields and methods of a class. This also helps to achieve **data hiding**.

```java
class Area {

  // fields to calculate area
  int length;
  int breadth;

  // constructor to initialize values
  Area(int length, int breadth) {
    this.length = length;
    this.breadth = breadth;
  }

  // method to calculate area
  public void getArea() {
    int area = length * breadth;
    System.out.println("Area: " + area);
  }
}

class Main {
  public static void main(String[] args) {

    // create object of Area
    // pass value of length and breadth
    Area rectangle = new Area(5, 6);
    rectangle.getArea();
  }
}
```

In the above example, we have created a class named Area. The main purpose of this class is to calculate the area.

To calculate an area, we need two variables: length and breadth and a method: `getArea()`. Hence, we bundled these fields and methods inside a single class.

Here, the fields and methods can be accessed from other classes as well. Hence, this is not **data hiding**.

This is only **encapsulation**. We are just keeping similar codes together.